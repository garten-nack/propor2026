**Pergunta 141**: O que é pós-poda e como ela funciona?

**Segmentos recuperados pelo E5**:
- *Corpus ID:* 1915
- *Score:* 0.8476065993309021
- *URL:* oculto
- *Início:* 01:25:21
- *Fim:* 01:27:18
- *Transcrição:* tá muitas vezes ela pode chegar um resultado bom assim bastante competitivo com pós poda o que pode acontecer é que essa esse orlestoping que é o que acontece com pré-poda tem essa desvantagem de ser o que a gente chama de uma estratégia gulosa porque Eu determino Essa é minha profundidade máxima por exemplo e eu e eu ignoro o fato de que depois daquela profundidade podem surgir algumas partições que podem melhorar eventualmente o desempenho Ou seja a profundidade máxima ela se ela for muito profunda ela pode piorar muito mas algo intermediário Pode ser que melhore um pouco meu desempenho e me dê regras mais específicas para alguns casos tá então Como tudo tem vantagens e desvantagem né o treinamento ele costuma ser mais rápido mas tem essa questão da gente ignorar o fato de que por exemplo depois de uma profundidade máxima de três na profundidade máxima de quatro poderiam surge coisas que até melhor o desempenho em relação a de três por isso que na prática o que a gente tem que fazer um processo de otimização de parâmetros a gente não tem muito como fugir disso tá de qual é o melhor critério de propósito após pó ela pode ser lenta quando tem um conjunto de dados grandes muitas instâncias muitos atributos mas ela tem de ser mais efetiva nesse equilíbrio entre complexidade e desempenho né o custo né aqui o desempenho estava chamando antes de custo né que é o próprio algoritmo custo complexidade porque o critério do algoritmo né o algoritmo que era um equilíbrio e aí a gente vai mudando o alfa para ver o quanto que a gente tá pesando a complexidade para reduzir mais a complexidade mas o algoritmo é guiado por esse equilíbrio então é natural que ele tenha um resultado melhor em termos desse equilíbrio certo porque é basicamente é o que nos orienta no algoritmo de custo complexidade

- *Corpus ID:* 1914
- *Score:* 0.835054874420166
- *URL:* oculto
- *Início:* 01:23:49
- *Fim:* 01:25:56
- *Transcrição:* difícil assim não existem regras de uso com os modelos porque para alguns domínios Eu tenho um desempenho parecido pode ser interessante eu ter um pouquinho mais de detalhe naquela regra que vai gerar ser gerada em outros domínios isso não importa para mim importa o desempenho tá então Claro árvores mais menos Profundas são mais fáceis sempre da gente interpretar mas eu tô falando de uma árvore por exemplo uma profundidade dois a outra três a dificuldade de interpretação não vai aumentar muito aumentando um nível só de profundidade e às vezes pode me dar uma riqueza na explicação daquilo se eu quero essa explicação tá então é como se fosse regras um pouquinho mais refinadas então para a gente concluir essa discussão né Se a gente for falar um pouquinho de pré-poda versus pós poda tá no geral se diz que a pré-poda ela é mais rápida digamos assim tá claro quando eu falo que é mais rápido é pensando no sentido de usar por exemplo se eu digo que a minha pré-poda vai ser profundidade máxima de 5 treinei o algoritmo ainda ainda terminei o algoritmo antes né do que o critério de parada tradicional e também é mais rápido mas a gente tem que lembrar que até coloquei aqui que eu preciso escolher normalmente esse melhor valor então embora o processo de pré-poda me retorne um treinamento mais rápido o processo de escolher o critério de pré-poda demanda um custo computacional tá muitas vezes ela pode chegar um resultado bom assim bastante competitivo com pós poda o que pode acontecer é que essa esse orlestoping que é o que acontece com pré-poda tem essa desvantagem de ser o que a gente chama de uma estratégia gulosa porque Eu determino Essa é minha profundidade máxima por exemplo e eu e eu ignoro o fato de que depois daquela profundidade podem surgir algumas partições que podem

- *Corpus ID:* 7048
- *Score:* 0.8313140869140625
- *URL:* oculto
- *Início:* 00:55:27
- *Fim:* 00:57:30
- *Transcrição:* espelhamento a gente vai fazer uma cópia do modelo então em cada device E essas cópias elas devem permanecer idênticas no final de cada passo de Treinamento Ok então como é que vai funcionar a gente tem um modelo representado deixa eu dar um zoom aqui pra gente visualizar melhor então a gente tem um modelo replicado igual o modelo é igual Ok para cada em cada uma das placas a gente tem três placas nesse exemplo aí o que que a gente vai fazer a gente vai a a fornecer para cada uma dessas placas três três betes o a o b e o c aí eh cada uma das placas estão vendo de maneira totalmente independente vão fazer atualização da PDA cálculo do Gradiente depois que fez o cálculo do Gradiente que é que é efetivamente o back propagation já atualizou o gradiente né aí a gente vai fazer essa operação coletiva ok que vai calcular a média Então vai ter assim tipo a correção que deve ser feita em cada uma dessas cópias para que no final tenha somente uma rede neural seja igual de novo ok então isso vai gerar então um um dado essa operação coletiva vai gerar um dado que vai ser utilizado e aplicado em cada uma dessas desses modelos eh de atualização né dos parâmetros E aí a gente vai ter de novo esses modelos eles são totalmente Independentes Mas agora eles estarão iguais de novo ok então assim é como se eh cada uma avança daí a gente faz essa operação coletiva de média suavisa E aí depois atualiza os modelos para que eles se tornem iguais de novo então assim no final desse dessa etapa aqui de gradientes os modelos terão divertidos eles não serão mais iguais mas como a gente faz essa suavização aqui a gente atualiza eles se tornam iguais de novo depois ok então no início de cada passo eles tê que ser iguais essa que é a ideia Garten pode pode perguntar então ele vai atualizar os pesos e os Bas né depois daquela operação de mim e e e vai ocorrer como se fosse uma então de todos esses

- *Corpus ID:* 1887
- *Score:* 0.8311986327171326
- *URL:* oculto
- *Início:* 00:39:05
- *Fim:* 00:41:13
- *Transcrição:* tá o pós poda ele é um pouquinho diferente porque eu falei para vocês ele vai treinar toda a árvore né ele não vai aplicar nenhuma restrição depois a gente vai ver que a gente poderia trabalhar com as duas coisas em paralela Tá mas em princípio não aplico nenhuma restrição em tempo de treinamento e depois que o treinamento é concluído né o que a gente faz é testar substituições de subir árvores por nós folhas de forma diminuir a complexidade mas mantendo Um Bom desempenho ou seja uma boa capacidade de generalização tá E aí eu vou comentar com vocês de um tipo de algoritmo de pós-poda que é o algoritmo usado no kart né que o kart é aquele que é baseado no índice Dini que Inclusive tem uma implementação disso no Sect planner que a gente vai olhar no notebook tá então o que que é o custo complexidade tá a gente pode pensar assim ó custo em relação ao desempenho taxa de erro de classificação Esse é o meu custo tá então qual é o custo de ter aquela árvore é o quanto que eu tô errando com aquela árvore e complexidade é em relação a estrutura da árvore com complexa ela é tá ou seja como é que eu codifica o tamanho da minha árvore Então essa ideia de custo complexidade é justamente Isso é uma função que considera né nessa função o número de nossas folhas né ou seja o tamanho dessa árvore e a taxa de erro do modelo tá que aí é o meu custo a taxa de erro por exemplo da classificação tá E aí o que que esse algoritmo faz ele vai iniciar da base ou seja não dou uma raiz né dos mais profundos e ele avalia para cada no interno como é que fica o custo complexidade da sub- árvore ou seja né daquela árvore que eu tenho a partir daquele nó interno tá e como é que fica a diferença se eu podar aquela sub- árvore ou seja se eu pegasse e trocar por uma folha onde esse na folha ele vai a saída dele vai ser determinado por exemplo pelo valor mais

- *Corpus ID:* 6797
- *Score:* 0.8295705318450928
- *URL:* oculto
- *Início:* 00:25:25
- *Fim:* 00:27:19
- *Transcrição:* internamente Talvez esteja implementado com como se fosse um callback né mas não é um callback do usuário né ali já seria o comportamento padrão é só o fato de estar verbose né né então o callback ele vai um pouco além disso porque o esses callbacks do usuário tu pode realmente salvar aquelas informações entendeu tipo assim colocar num log entendeu ou já eh disparar um processo que vai criar um gráfico esse gráfico vai se atualizar na medida que vai vai acontecendo os treinamentos Entendeu Como se tu tivesse por exemplo telas de acompanha acanhamento né tu lança o treinamento imagina leva semanas né as pessoas querem ficar olhando se tem algum ind algum dos treinamentos indo bem aí tu faz ess tipo de então é para fazer coisas mais sofisticadas do que simplesmente ver aquelas informações textuais na tela né que não tem como tu salvar né Eh até bom até tem como salvar né tu vai ter esse log né Mas tu redirecionar a saída né para um arquivo né mas é uma coisa bem muito muito simples daí no caso né comparado com callback né então assim aqui nesse exemplo a gente tá usando uma uma uma classe certo essa classe já existe ela tem um propósito que é fazer o Model checkpoint Mas a gente pode customizar com as nossas próprias funções então por exemplo a gente pode instanciar essa classe meu callback aqui né que ela erda de callback do que eras E aí dentro dessa Classe A gente vai ter uma série de métodos que a gente pode sobrescrever e esses métodos são os métodos que efetivamente vão acontecer tem determinados momentos né tipo assim os métodos eles são pré pré listados eles pré existem né A gente só vai sobrescrever Aqueles que a gente deseja né então um que é bastante interessante de sobrescrever É esse aqui que se chama on epoc end que significa assim que no final de uma época ele vai lançar esse método ele vai invocar esse método se

- *Corpus ID:* 1950
- *Score:* 0.8294224739074707
- *URL:* oculto
- *Início:* 00:54:51
- *Fim:* 00:56:58
- *Transcrição:* eu quero pessoal eu vou eu vou adiante isso vocês podem adiciodo depois tá eu não vou discutir essa planilha hoje tá bom mas depois a gente vai voltar nela por isso que eu digo não importa é esperado que os resultados variam um pouco tá bom o que que eu quero fazer agora com vocês Justamente a gente visualizar os efeitos da poda né a gente vai fazer prepota depois pós poda e observar como é que eu posso ajustar esse preparamento da poda tá então assim a gente tô fazendo a divisão que os dados vocês vão perceber que eu tô fazendo a divisão de novo né só porque aqui eu tô definindo o Rainbow state enfim as outras divisões elas foram dentro de looks Então a gente vai repetir essa divisão para que todo mundo use o mesmo treino teste né porque a última divisão não tava usando O Windows state E aí a gente vai fazer algumas análises no seguinte peguei a divisão no treino teste né 20% para teste nos 80% para treino deixa aumentar aqui um pouquinho eu tô só para vocês observarem eu tô criando um classificador trata de decisão e que eu tô estipulando que a profundidade máxima é dois completamente arbitrário aqui tá se vocês executarem tenham pessoal tem algum microfone aberto se vocês puderem fechar se vocês executarem vocês vão ver que a nossa árvore de decisão aqui mudou certo Por que que ela mudou porque Claro tem os mesmos a mesma ideia dos áudios de Treinamento a gente observou lá no início né que conforme a gente usava dados diferentes a gente tinha árvores diferentes mas ela sem ela sempre tendiam a ser bem Profundas e aqui eu determinei que eu tenho uma árvore de profundidade máxima 2 então através desse prepaâmetro Max teto igual a dois eu disse olha a profundidade máxima 2 então que é um exemplo de pré-poda tá

- *Corpus ID:* 7243
- *Score:* 0.8292521238327026
- *URL:* oculto
- *Início:* 00:16:07
- *Fim:* 00:18:42
- *Transcrição:* selada e agora o que que esse cara tá fazendo é fazendo o pin Hold né E esse aqui é o resultado da projeção da cena que tá na frente da câmera na frente da janela né dentro da sala A então como vocês podem perceber né Essa parede oposta ao orifício ela de fato mostra a cena n que ocorre no lado oposto do orifício né de maneira invertida tá então aqui tem de novo alguns detalhes de como eles fizeram isso aí tá mas Teoricamente qualquer um de vocês pode fazer esse experimento só tem que ter uma janela uma uma sala né onde eu tenho uma janela ela para eu poder cobrir e fazer o orifício e a parede oposta tem que ser de preferência Branca né porque se for preta eu não vou conseguir ver nado tá bom ah obviamente que hoje em dia embora as câmeras sigam basicamente essa ideia pelo menos a formulação matemática é muito parecido com isso tá o que a gente tem hoje em dia é que a gente faz esse processo ou algo parecido e a gente consegue salvar essa imagem né então antigamente a gente salvava essa imagem no filme hoje em dia tem um sensor que daí joga para um cartão de memória e a gente consegue capturar né exatamente essa imagem que tá sendo Projetada na câmera obscura tá então com relação a fotografia mesmo a captura e eh os os registros originais eh são atribuídos a ao nipse desculpa provavelmente tô pronunciando errado tá é é um francês né E aí tem toda uma uma mistura química e aí é uma parte que obviamente eu entendo muito pouco né que é exatamente como Qual é a química que tem que ser usada para que quando bata um fóton de luz essa essa região ela seja excitada de tal maneira que isso fique ah perenizado depois de algum processo n então de novo fazendo analogia com filme analógico né a gente tinha uma

- *Corpus ID:* 7145
- *Score:* 0.8286778926849365
- *URL:* oculto
- *Início:* 00:45:31
- *Fim:* 00:47:46
- *Transcrição:* de fazer isso de forma Global né É porque de uma forma ou de outra eu já tô entendendo né eu eu sistema né Já tô entendendo alguma coisa associado a profundidade por exemplo né então quer dizer eu sei que para lá tá mais claro do que para cá então de repente eu escureço mais para lá do que para cá e de repente eu escureço em algum eh com algum nível de Fade né e e isso já me dá D uma uma melhora Visual na aplicação tá então tem uma série de de aplicações né que envolvem entendimento de cena e que são úteis aí no ã no nosso dia a dia tá pó processamento de vídeo a mesma coisa né então Eh quando a gente clica em borrar o fundo por exemplo né isso tem um pouquinho de entendimento de cena e pós processamento de vídeo também né então a minha imagem ela tá sendo capturada eh do jeito que a minha câmera é capaz de capturar né A minha câmera não tem um sensor de profundidade mas eu tenho um sistema provavelmente baseado em em Deep learning né que é capaz de determinar o que que é foreground que que é eu né no caso e o que que é background tudo o resto né tudo todo o nosso fundo e aí quando eu borro o fundo né eu tenho essa separação de foreground e background tô entendendo que que tem um objeto que se move tô entendendo que tem todo um background Ô de alguma forma identificando eh o que tá na frente do que né Às vezes a gente sabe que esse negócio não funciona tão bem mas mas é uma algo nesse nessa linha né tows ã entendimento de cena hã detecção de faces reconhecimento estimação de pose né então acho que eh eh essa questão de detecção de Face eh é algo bem comum no nosso telefone por exemplo né então a gente pega o telefone e na hora de tirar uma foto ele às vezes coloca né dependendo do modoo de foto que a gente tá ele coloca um quadradinho em volta de uma Face e e tenta melhorar tenta fazer algum

- *Corpus ID:* 3360
- *Score:* 0.828113853931427
- *URL:* oculto
- *Início:* 01:15:57
- *Fim:* 01:18:41
- *Transcrição:* Então processar o que veio antes dúvida Antônio é o último estado da rede ou ele é tipo uma filha que ele guarda os novos pisos Palhas entendeu eu tive um pouco de dificuldade para ouvir não sei se ficou um pouco baixo mas eu vou tentar aqui o que que eu consegui pegar dizendo que tá ruim o estado oculto da rede valores é apenas um o estado anterior da rede ou ele guarda uma pia de estados anteriores que tem pela calcular período só aumentado ele guarda uma família mesmo né onde ele vai desempenhando até chegar no determinado tá entendi a pergunta eu acho que o próximo slide vai ajudar nisso tá eu vou colocar aqui o próximo slide copiar aqui o conteúdo para a gente poder avançar porque vamos ver como é que é o processamento agora tá Deixa eu só mover aqui de novo mover para o lugar melhorzinho aqui as coisas para ficar bem bem visível aqui para a gente tava mais ou menos Qual que é a ideia agora o cálculo né Deixa eu seleção da ferramenta ativação vermelha ativação Vermelha em um momento vamos pegar o primeiro dado aqui ó ativação vermelho Na verdade em qualquer momento vai ser assim tá mas a ativação vermelha vai ser é o peso vermelho vezes o X1 vou colocar o X1 de preto Porque ele é o dado de entrada mas o peso o peso de memória né o ver aqui ó vezes ativação anterior é no primeiro momento quando vem o primeiro dado aqui essa ativação não existiu né então a gente pode colocar ela como zero tá no primeiro momento aqui e mais o mais aí tem esqueci né o potência a função de ativação em cima disso né então esse ativação vermelha e aí então eu faço né

- *Corpus ID:* 3445
- *Score:* 0.8275556564331055
- *URL:* oculto
- *Início:* 01:24:38
- *Fim:* 01:27:11
- *Transcrição:* né depois então eu tenho no código né a sequência de coisas no código é assim ó camada aí como um parâmetro da camada eu posso colocar né tem os parâmetros normais lá né Se for camada de convolucional tem os filtros etc e tem a regularização regularização regularization lambda lá perdão aí depois a camada vem se eu quiser colocar outra E se eu quiser colocar o pet nome eu vou e coloco como se fosse uma camada né que viesse Depois dessa e o Beto nome fosse uma camada que viesse Depois dessa eu ia colocar né tem que colocar depois se você colocar antes aqui se eu colocar droppauts e bett enorme antes ele vai fazer ele vai atacar a camada anterior a ele tá entendendo o oposto tá ligado Professor isso o drop falte e o mexe normalization atacam né a camada que vem antes deles certo tá então né isso assim a gente consegue né Por enquanto tá nosso kit de ferramentas tá crescendo aqui agora uma última coisa é um pouco menos fácil de fazer em termos de código tá é conexão de salto aqui ó que Conection né ou camadas residuais A ideia é evitar o gradiente que some ao criar esses saltos mesmo a conexão de salto é um atalho aqui de informação qualquer ideia né então eu tenho uma rede profunda lá né que tem entrada aí tem aqui uma duas três camadas como funcionais E aí aqui tem aqui né uma um exemplo né usando a convolução normalização por Beth e ativação enfim é um diagrama tá não quer dizer que no código segue essa sequência não mas é só um diagrama que tá indicando que existe né a camada de convulsão tá com normalização por Beth e tá com ativação Reluz né o jeito que faz isso no código é lá da forma que é especificado não


**Resposta gerada pelo LLM**: Pós-poda é um método que treina toda a árvore sem restrições e, após o treinamento, testa substituições de subárvores por nós folha para diminuir a complexidade, mantendo um bom desempenho. Um algoritmo de pós-poda usado é o baseado no índice de custo-complexidade, que considera o número de nós folha (tamanho da árvore) e a taxa de erro do modelo.  Ele inicia da raiz, avaliando para cada nó interno como fica o custo-complexidade da subárvore e a diferença se podada (substituída por uma folha).

**Referências**:
- [Vídeo de referência oculto]()

**Anotação manual**: C

**Answer Relevance (AR)**: 1.00

**Anotação automatizada**: C

**Raciocínio (AR CoT)**: Criteria: The RESPONSE must be relevant to the entire PROMPT to receive a maximum score of 3. Supporting Evidence: The RESPONSE provides a clear explanation of what pós-poda is and how it functions, directly addressing both parts of the PROMPT. It describes the method of pós-poda, the process involved, and mentions an algorithm used in this context, which aligns with the request for understanding the concept and its operation. Therefore, it is fully relevant to the PROMPT.  Score: 3


---
