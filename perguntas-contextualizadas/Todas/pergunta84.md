**Pergunta 84**: Como os algoritmos de agrupamento lidam com a localização inicial dos centros de gravidade quando o número de grupos é desconhecido? 

**Segmentos recuperados pelo E5**:
- *Corpus ID:* 3585
- *Score:* 0.8821713328361511
- *URL:* oculto
- *Início:* 01:14:51
- *Fim:* 01:17:21
- *Transcrição:* nós vamos ver que tem coisas que nos ajudam a saber se essa quantidade escolhida foi bem feita né existem processo interativos que eu peço para ele fazer a divisão em um dois três eu escolho de um intervalo né normalmente de 1 a 10 mas pode ser mais e ele repete o processo para um para dois para três para quatro para 10 para quando se eu quiser e aí eu uso alguma métrica de qualidade para me dizer olha desses todos que eu tentei o que parece melhor é esse com três esse com quatro esse com cinco e aí vocês usam aquele Então esse é um é um dos é um dos parâmetros se preparamos enfim e outro deles que também é uma coisa curiosa é que eu preciso dizer aonde os centros de gravidade vão estar e eu posso escolher qualquer lugar da mesma forma que eu não sei né quantos grupos eu tenho como é que eu vou saber aonde estão os centros de gravidade desses desses elementos então parece muito ruim esse algoritmo mas ele funciona e então que existe normalmente é que é feito uma uma escolha aleatória é algoritmo coloca no espaço esses centros em qualquer lugar avalia o resultado se ele foi ruim repete Com outras posições diferentes e aí eu vou fazer isso várias vezes o algoritmo padrão que vem em parto ele faz isso 10 vezes vocês podem escolher 100 vezes quanto mais vezes vocês escolherem melhor mas aí vai depender da quantidade de dados que vocês têm do tempo disponível Enfim então a gente tem que tem que avaliar esse traidor aí de qualidade versus tempo disponível e mas enfim a gente vai ver como fazer isso depois vocês podem experimentar não é também tão demorado com quantidades que nós vamos usar Mas enfim Num caso mais realista com muitos elementos a gente vai ter que cuidar essa questão Existem algumas algumas heurísticas que foram criadas e que também estão implementadas nós vamos ver aí na biblioteca Python em outras

- *Corpus ID:* 3626
- *Score:* 0.8772046566009521
- *URL:* oculto
- *Início:* 01:02:40
- *Fim:* 01:05:07
- *Transcrição:* todos distribuídos de maneira a ter uma distância é que distante entre eles seria mais ou menos isso vou dizer que é impossível mas é muito difícil então chegar a zero é quase impossível quanto mais próximo de zero mais coesos eles estão mais ao redor do centro eles estão e os elementos de classes diferentes estão mais espalhados É só isso que isso significa e vejam que esse conjunto de dados ele ele foi um conjunto relativamente fácil ele em duas interações ele conseguiu convergir no resultado né em alguns casos pode ser mais difícil se eu quiser saber pode ser interessante para mim qual quais são os centros de gravidade que ele que ele achou eu tenho uma propriedade né do modelo que é justamente os centros de gravidade ela me devolver as posições de cada um dos três centros Então são essas as posições de gravidade que ele encontrou como sendo melhores para esses três conjuntos e também eu posso pedir para ele me dizer a qual etiqueta que ele atribuiu para cada elemento eu tenho aqui uma também o resultado que é uma reina é uma dimensão ele vai me dizer bom pro primeiro eu dei a etiqueta dois para segunda dente que tá zero para o terceiro etiqueta um e assim por diante aqui tem uma coisa muito importante essas essas etiquetas elas não tem um significado a não ser dizer que eles pertencem a clusters diferentes porque eu quero dizer com isso é que algumas vezes dependendo de onde ele posicionou o centro ele pode que ele vai pegar a ordem que os centros foram posicionados né então ele eventualmente pode dizer olha esse cara aqui ele tem o cluster ele ficou colocado ao cluster zero é porque porque o centro de gravidade estava mais o primeiro deles são mais próximo dele é isso vocês rodarem de novo ele pode

- *Corpus ID:* 3587
- *Score:* 0.8753957152366638
- *URL:* oculto
- *Início:* 01:18:30
- *Fim:* 01:20:43
- *Transcrição:* isso elas com base em uma pressuposição de distribuição ao invés de escolher aleatoriamente um centro elas tentam posicionar aonde dentro dessa distribuição ficaria mais adequado eu colocar o centro então isso nos ajuda Se for possível fazer isso E aí depois eu eu vou tentando alocar os elementos aos centros de gravidade mais próximos a eles e uma vez que o alok um elemento a um centro de gravidade o câncer passa a envolver esse elemento também então o seu centro de gravidade muda eu tenho que reposicionar o centro de gravidade para que ele considere esse novo elemento então ajusto central de repito esse processo até que os elementos não não mudem mais de centros centróis não mudem mais de posição então eu tenho eu tenho um exemplo visual Imaginem que eu receba esse conjunto de dados aqui eu tô botando ele visualmente ele visualmente no espaço mas nem sempre eu vou ter isso e eu decido que são três a que eu dei um chute certo tem três Aparentemente o algoritmo inicializa vejam aqui o centro de gravidade né colocou um aqui um aqui um aqui aleatoriamente vejam que eu posso ter o azar ele colocar os três no mesmo muito próximo né aí eu vou levar mais tempo para convergir para chegar numa resposta correta posso colocar os três totalmente fora aqui ou distância enfim como é aleatório vão acontecer coisas diferentes a cada execução Mas enfim aqui ele escolheu esses três e aí o que ele faz é eu pego cada um dos elementos e avaliam um exemplo peguei ali esse elemento a qual dos centros ele está mais próximo a esse aqui então ele junta esse elemento a esse a esse centro isso se repete a todos os outros elementos né que aqui eu peguei o verde e aloquei nesses Android

- *Corpus ID:* 3622
- *Score:* 0.8746838569641113
- *URL:* oculto
- *Início:* 00:55:47
- *Fim:* 00:58:07
- *Transcrição:* diferenças entre a distância entre um elemento e o centro ele faz uma média então calcula cada um deles cada uma das diferenças entre o centro e os elementos todos que estão no mesmo cluster e faz uma média dessa diferença e depois também globalmente divide isso pelas outras pelas outras médias então ele tem uma proporção aí tentando dizer o pão com eles estão os classes Então esse esse parâmetro de desfaz 10 vezes isso e pega aquela cujo ss e inércia era um valor menor quer dizer aquele dentre os 10 que tiver melhor Coesão e acoplamento e tem mais um parâmetro aqui que é importante Se vocês lembrarem do funcionamento do algoritmo ele pega um elemento e tenta colocar num cluster mais próximo e ele repete isso para todos os elementos e ele vai fazendo isso sempre até que o centro de gravidade né Vocês lembram eu aloco um elemento num cluster e ele recalcula o centro de gravidade ele vai tentando reposicionar né os elementos nos centros mais próximos e como centros mudam o posicionamento dos elementos nos flashes também ele pode mudar então pode ocorrer situações em que ele não termina nunca ele bota um elemento num cluster puxa o centro de gravidade para cá E aí um outro elemento que era próximo desse centro pode passar a ser mais próximo de outro centro já que o centro da cidade mudou e ele fica tentando mudar os elementos de os centros até que não haja mais mudanças só que pode ser que ele não chegue no resultado onde não haja mais mudanças então eu posso dizer para ele que eu quero que ele tente no máximo fazer isso em tantas interações né então tô dizendo aqui no máximo 300 vezes ele vai tentar reposicionar e se nessas 300 vezes ele não achou uma estabilidade ele para e pega o que o que o que acabou ali resultando Então a maneira de controlar o algoritmo também então quanto mais inicializações

- *Corpus ID:* 3588
- *Score:* 0.8724452257156372
- *URL:* oculto
- *Início:* 01:20:03
- *Fim:* 01:22:17
- *Transcrição:* posso colocar os três totalmente fora aqui ou distância enfim como é aleatório vão acontecer coisas diferentes a cada execução Mas enfim aqui ele escolheu esses três e aí o que ele faz é eu pego cada um dos elementos e avaliam um exemplo peguei ali esse elemento a qual dos centros ele está mais próximo a esse aqui então ele junta esse elemento a esse a esse centro isso se repete a todos os outros elementos né que aqui eu peguei o verde e aloquei nesses Android o roxo a esse e Eu repito assim uma vez que eu aluguei um elemento a um centro eu tenho que reposicionar o centro então faça uma média entre o que ele tinha antes e considerando elemento novo Então veja que o centro foram reposicionados agora para aqueles representam esse esse conglomerado isso se repete ao alocando novos elementos e reposiciodo os centros até que no final então eu vou ter um centro de gravidade na posição mais correta considerando um conjunto de elementos nós temos desométricos né quer dizer todas as dimensões estão os elementos estão afastados no máximo um determinado raio Esse é o funcionamento básico do algoritmo uma coisa muito importante talvez vocês tenham percebido se não vou chamar atenção toda vez que vocês executam algoritmo ele pode dar um resultado diferente justamente porque a inicialização dos Santos ela é aleatória então é claro que ele vai tentar maximizar não é e ele vai funciodo até que os santos não modifiquem mais então ele converge normalmente bem a gente tem matematicamente o que a gente chama de problema dos mínimos mínimos locais quer dizer pode ser que ele às vezes por causa das configurações dos grupos ele ele acha que que aquele

- *Corpus ID:* 3676
- *Score:* 0.8719505071640015
- *URL:* oculto
- *Início:* 00:48:09
- *Fim:* 00:50:33
- *Transcrição:* essa combinação mais à esquerda que ela já não é muito boa né a gente não até enxerga aqui um pouco mais lá que eles estão mais mais dispersos e uma separação não muito boa então a gente eventualmente pode ou não remover alguma uma variável né Isso é uma ideia talvez remover alguma variável se essa variável não não combinada com as outras né não não gera gera uma expressão muito grande não gera nenhuma agrupamento Mas enfim a ideia de mostrar para vocês isso é justamente ter esse essa em mãos né uma ferramenta simplificada e que rapidamente pode dar indícios tanto de quantos quantos agrupamentos podem existir né como também de se aquelas variáveis elas são úteis ou não E aí em termos de distribuição a gente tem aqui essa versão do gráfico né que usa um Kernel gaussiano justamente ele tenta ele tenta colocar no avaliar né e colocar no espaço os elementos tentando mostrar o centro de gravidade né E aí ao redor desse centro se isso tá bem distribuído como uma curva normal só que aí em duas dimensões para pai então a gente consegue perceber também que existem centros de gravidade mas também consegue avaliar de certa forma assim se são ou não curvas normais né então algumas são mais achatadas aqui é bem caudal e Aqui também deu uma bical Mas enfim a gente tem aqui algumas alguns indícios de que que tem teria uma certa normalidade nesse conjunto de dados que que dois pelo menos centros de gravidade existem talvez aqui uma tendência é um terceiro centro né dá para ver aqui essa essa ponta saliente então dois ou três ele é o chute né aqui dá para ver isso mais à esquerda tanto aqui em cima quanto aqui embaixo ele dá uma ideia né que talvez três

- *Corpus ID:* 3773
- *Score:* 0.8667609691619873
- *URL:* oculto
- *Início:* 00:41:01
- *Fim:* 00:43:26
- *Transcrição:* grupos aqui nessa figura dá para perceber a diferença entre médias e o camedóides né pega um centro qualquer de gravidade o camedóides Escolhe um dos elementos como centro então vocês vejam que ele colheu um deles mas enfim o resultado não muda o FC Miss também não não conseguiu pela estrutura de funcionamento deles depois a mesma coisa para o círculos eles nenhum deles consegue identificar e depois a mesma coisa para duas classes né que estão alongados não original caminhos camedóides vai ser minha estejam que ele quebra eles podem tentar rodar diferentes vezes para ver todas elas o grande parte delas ele não tem um deles vai conseguir então esses conjuntos eles não são bons para esses algoritmos né pelo código é que vocês podem ver não tem muito mistério mas esse primeiro ele gera os conjuntos de dados tá então eu eu peço para ele gerar coloco numa numa tabela que cada um deles tem uma tabela diferente é o DF uns DF certo com os deve classification então tem os elementos em seus pontos né x y desses desses clusters e numa das colunas vocês têm também se vocês quiserem botar eu não cheguei a botar aqui tenho a qual Classic cada um deles qualquer categoria cada um pertence né classes um classes 2 classes 3 então com isso vocês conseguiram fazer alguma avaliação comparação dos resultados e depois aqui embaixo tem um script para cada algoritmo opinião script para cada conjunto de dados e eu rodo os três algoritmos eu escolhi uma configuração aqui específico vocês quiserem tentar outras vocês podem depois mas vocês vão ver que dificilmente ele vai resolver o problema então ele gera o caminho se ele gera o FC Mix e ele gera o camedóides E aí para todos eles ele ele coloca na

- *Corpus ID:* 3926
- *Score:* 0.8665878772735596
- *URL:* oculto
- *Início:* 00:00:08
- *Fim:* 00:02:49
- *Transcrição:* Então bom dia a todos todas bem-vindos bem-vindas eh hoje nós vamos começar na sexta aula trabalhando com clusterização de um tipo específico de conjunto de dados mas e uma dúvida que surgiu aí então foi a do exercício da aula passada exercício dois não é eh deixa eu gravar a tela aqui partilhar E aí eu vou só mostrar o os bate-papo então Eh em especial aqui né né no algoritmo cedoes cedoes eh ele é um algoritmo que a o parâmetro resultante ali de inércia que no camin é a métrica sse eh não corresponde ao sse ele corresponde a outra situação e aí olhando a documentação aqui vocês vão ver e o que ele devolve aqui como como inércia não é é a soma das distâncias dos os elementos que pertencem àquele cluster ao centro então ele não ele não faz como o sse que que Pondera isso pela distância dos elementos aos outros clusters né então no SSL ele combina eh a proximidade os elementos com seus clusters mas também a separação desses clusters em relação a outros não é então a a a dúvida que surgiu não é que se é que se é se nós podemos usar a a a métrica doot velo não é para como base como heurística para decidir a quantidade de cluster então Eh nessa nessa figura aqui dá para ver que existem existem alguns pontos de inflexão não é e esses pontos de inflexão que nós podemos dizer sobre essa Ótica é que existem eh pontos em que os elementos estão muito mais próximos do centro e esses pontos são aqui o dois o o se e depois o 10 aí e intuitivamente e naturalmente quanto mais clusters eu tenho menos elementos são alocados a esses clusters e provavelmente como tem menos elementos esses elementos também são alocados aos centros mais próximos então é natural

- *Corpus ID:* 3589
- *Score:* 0.8663599491119385
- *URL:* oculto
- *Início:* 01:21:43
- *Fim:* 01:23:52
- *Transcrição:* Santos ela é aleatória então é claro que ele vai tentar maximizar não é e ele vai funciodo até que os santos não modifiquem mais então ele converge normalmente bem a gente tem matematicamente o que a gente chama de problema dos mínimos mínimos locais quer dizer pode ser que ele às vezes por causa das configurações dos grupos ele ele acha que que aquele elemento não se mexe mais né porque a média ficou limitada o pessoal normalmente faz um gráfico mostrando né o erro médio quadrado que mede as distâncias entre o centro e todos os elementos e a ideia é que ele chegue no mínimo aqui aí depois começa a subir de novo então o segredo é achar esse mínimo aqui é o ponto aonde o erro é o menor possível o problema é que eventualmente existem erros intermediários aqui E aí ele pode achar aqui que ele chegou no mínimo e aí ele não sai mais se ele for para direita sobe sobe para esquerda sobe então ele acha que achou o menor erro possível mas mas existe um erro menor mais embaixo Então matematicamente os edifícios dele identificar esse esses mínimos locais né globais digamos assim ele acha um mínimo local Então nem sempre eu com um vídeo eu tenho convergência Mas eu posso rodar várias vezes o algoritmo e a escolher aquela que o resultado Deu melhor e também existem algumas técnicas que nós vamos ver que vai vão tentar evitar isso então a gente diz que esse é um algoritmo não determinístico né porque toda vez que eu rodo ele pode dar um resultado diferente Mas uma vez que eu achei um modelo e vi que esse modelo adequado eu posso usar os parâmetros e o modelo que foi feito e eventualmente a teclasterizar novos

- *Corpus ID:* 3597
- *Score:* 0.8646668791770935
- *URL:* oculto
- *Início:* 00:09:35
- *Fim:* 00:12:02
- *Transcrição:* seguem o algoritmo né que respeitation que que considera então alguns elementos matemáticos cujo o objetivo é justamente avaliar se os clãs estão coesos ao redor desse centro e ao mesmo tempo separados uns dos outros e basicamente ele funciona criando não é clusters que são eu chamo de isométricos né quer dizer eu tenho um centro de gravidade e independente da quantidade de dimensões que eu tenho existe um raio máximo que ele vai considerar para locar os elementos num câncer ou no outro no centro de gravidade ou no outro então dentro dessa se for duas dimensões um círculo três dimensões mais fera bom mais dimensões aí nem sei o nome da figura geométrica mas enquanto enquanto o espaço não é eles vão estar ao redor desse desse centro de gravidade por isso isométrico porque tem todas as dimensões que eu tiver ele vai ter esse raio máximo e nem sempre o meu conjunto de dados é isométrico né Nós vimos ali alguns que são alongados outros que são interseccionados então ele não vai funcionar bem para todos os casos todos os conjuntos de dados mas enfim para aqueles que tiverem essa característica ele vai funcionar bem Vamos tentar avaliar né Quais são os casos que ele que ele funciona melhor então em termos de implementação como eu já tinha mencionado nós temos na linguagem paypton curso tem usado na biblioteca chamada que você já devem ter usado em outras situações essa biblioteca tem algoritmos de aprendizado não supervisionado Então nós vamos utilizá-la mas adiante nós vamos usar uma outra biblioteca também para vocês terem mais de uma alternativa e perceberem que certa forma são parecidos os algoritmos é que dependendo da biblioteca o processo ele pode ser melhor organizado pode ser interessante


**Resposta gerada pelo LLM**: Em alguns algoritmos, a localização inicial dos centros de gravidade é escolhida aleatoriamente.  O algoritmo então avalia o resultado e, se ruim, repete o processo com outras posições.  Em outros casos,  as posições iniciais são determinadas com base em uma pressuposição de distribuição dos dados, tentando posicionar os centros onde seriam mais adequados.

**Referências**:
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()

**Anotação manual**: C

**Answer Relevance (AR)**: 1.00

**Anotação automatizada**: C

**Raciocínio (AR CoT)**: Criteria: The RESPONSE must be relevant to the entire PROMPT to receive a maximum score of 3. Supporting Evidence: The RESPONSE addresses the PROMPT by discussing how clustering algorithms handle the initial placement of centroids when the number of clusters is unknown. It mentions the random selection of initial positions and the evaluation of results, which directly relates to the prompt's inquiry about the handling of initial centroid locations. Additionally, it provides an alternative method where initial positions are based on assumptions about data distribution, further enhancing its relevance to the entire prompt.  Score: 3


---
