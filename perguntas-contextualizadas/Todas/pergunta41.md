**Pergunta 41**: Quais são os três desafios principais que surgiram com o surgimento dos bancos de dados distribuídos?

**Segmentos recuperados pelo E5**:
- *Corpus ID:* 8874
- *Score:* 0.8702828884124756
- *URL:* oculto
- *Início:* 00:07:07
- *Fim:* 00:09:47
- *Transcrição:* para outro eh igualmente consistente e a durabilidade então depois né de executadas as transações e a base de dados modificada então o resultado então ele é permanente né então né o banco de dados o sgbd Então tem que garantir que o resultado atualizado né vai eh ficar sempre disponível por usuário mesmo que ocorra alguma algum tipo de F então aqui do ponto de vista né do eh do que a gente tá estudando né dos bancos de dados no SQL o ponto principal né aqui dos relacionais O que que a gente tem tem uma consistência da base de dados né então em todo momento a base de D vai tá correta vai tá consistente e a gente tem a disponibilidade que é os dados então eles estão disponíveis para as aplicações utilizarem né então no nos bancos de dados relacionais então que a gente tem então são eh são essas restrições E aí qualquer sgbd relacional então ele Obrigatoriamente tem que manter eh eh essas quatro características né de de de restrições de integridade tá então isso aqui é o que vem aí desde lá da década de 70 aí com a evolução dos bancos de dados né então a gente eh com o surgimento dos bancos de dados distribuídos então Eh para manter eh essas quatro restrições agora a gente tem eh três TR desafios né três ideias centrais que antes da distribuição a gente não tinha né então é o particionamento de dados né então no momento em que a gente particiona os dados né então tem o dados em locais uma parte né da minha base de dados tá num local outra parte tá em outra eu preciso continuar mantendo eh essas quatro eh restrições né lá no início dos bancos de dados distribuídos E aí aumenta então a dificuldade de manter a consistência e também a gente tem o problema de desempenho né então para de desempenho

- *Corpus ID:* 8875
- *Score:* 0.8686685562133789
- *URL:* oculto
- *Início:* 00:09:07
- *Fim:* 00:11:54
- *Transcrição:* é o particionamento de dados né então no momento em que a gente particiona os dados né então tem o dados em locais uma parte né da minha base de dados tá num local outra parte tá em outra eu preciso continuar mantendo eh essas quatro eh restrições né lá no início dos bancos de dados distribuídos E aí aumenta então a dificuldade de manter a consistência e também a gente tem o problema de desempenho né então para de desempenho disponibilidade então para deixar as informações disponíveis E consistentes então a gente né tem que fazer bloqueio né ou tem que fazer atualizações e a gente pode ferir Então essas duas necessidades principais né que é a consistência e a disponibilidade o outro ponto então é a replicação né então para melhorar disponibilidade então a gente né iniciou então Eh replicar dados eh em locais diferentes e aí com isso a gente melhora a disponibilidade mas aí a gente coloca em risco a consistência né porque em todos os locais onde a gente tem os dados replicados eles precisam est iguais e consistentes né E aí para resolver esse problema aí a gente tem né uma outra alternativa né uma outra ideia que é a ideia de Cash então aí a gente deixa disponível né então a gente tem um tempo mais rápido de resposta mas aí o problema que a gente tem é que né se eu mudo eh a informação mudo o dado né lá no local onde ele tá armazenado então para manter a consistência Então eu tenho que garantir né que eh tenho que atualizar também o que tá em memória então eu melhorei o desempenho e coloquei em risco a consistência né então em bancos de dados distribuídos né então aqui só exemplos ali do que a gente viu né então eu posso ter lá da parte de compartilhamento de dados né eu tenho uma parte do dado que tá num servidor A outra tá em outro a outra tá em outro e a gente precisa eh eu aumento o desempenho porque eu

- *Corpus ID:* 8879
- *Score:* 0.8682422041893005
- *URL:* oculto
- *Início:* 00:17:26
- *Fim:* 00:20:13
- *Transcrição:* para em cada um dos casos né a gente vai analisar o contexto da aplicação né E aí a gente vai ver quais são as necessidades prioritárias então tem alguns bancos de dados que mantém as três né aí a gente vai ter Possivelmente alguma penalização de desempenho mas muitos então assim o que é rígido que mantenha pelo menos duas restrições né então se eu pego por exemplo eh se lá um sistema bancário por exemplo eu preciso ter consistência e preciso ter disponibilidade né se eu pego por exemplo uma rede social eu posso eh assim deixar consistência ameaçada né então por exemplo posso levar um pouco mais de tempo para fazer alguma atualização que não vai prejudicar eh o resultado em si da aplicação Então dependendo né da aplicação então a gente faz a escolha eh das combinações que são mais relevantes e mais importantes para cada uma das aplicações professora Oi sim uma dúvida então assim eh nessa nesse cenário né de de bancos de dados distribuídos eh é importante que se Garanta pelo menos duas dessas três colocadas né exato sim mas há casos que o que que bancos distribuídos atendem as três restrições é isso só a cas eh isso desculpa eu é que deu um retorno e eu acho Desculpa eu achei que você tivesse terminado pode continuar não era era só eh confirmando esse entendimento então há casos que que os bancos atendem as três restrições só que aí a gente vai ter um desempenho pior isso é então a assim o que a literatura propõe é assim ó que se eu mantenho duas a gente vai ter uma consistência da base de dados né mas muitos assim vendem que conseguem manter as três e aí a gente perde um pouquinho em disponibilidade a logo na sequência Então vou vou falar dos bancos de dados no SQL que tem uma flexibilidade maior ainda né mas os fantes atuais eles eh querem garantir todas as propriedades que é o que seria ideal né então eles eh

- *Corpus ID:* 8885
- *Score:* 0.8676169514656067
- *URL:* oculto
- *Início:* 00:29:43
- *Fim:* 00:32:29
- *Transcrição:* importante aí o que que acontece né então a gente vai eh pras para pro teorema Cap de novo né então o início quando eh os bancos de dados no o SQL surgiram então nas primeiras aplicações então a ideia era usar continuar usando né as três restrições e usando o teorema Cap porque a gente continua né Com todas essas características de distribuição né então aqui a gente tem duas características nov novas Mas não tão novas né que é o aumento do volume de dados e a estrutura dos dados Então ela passa a ser mais flexível mas a gente então precisa Então desses três fatores né Eu preciso da consistência preciso da disponibilidade e como né os dados estão particionados Então se a gente tem falha no nó ou se a gente tem falha na rede então a gente pode eh colocar em risco a consistência ou a disponibilidade ou as duas coisas né então aqui pros bancos de dados no SQL né então o que que a gente tem a gente tem eh aplicações eh lá nos bancos de dados distribuídos né então antes de todo esse advento dos nocel a maioria das aplicações que são aplicações transacionais então Eh precisam muito da consistência né então quanto mais a gente aumenta eh a consistência é mais difícil de implementar e a gente acaba perdendo no desempenho né quando a gente eh diminui a consistência então né o sistema fica mais rápido e fica mais fácil de implementar então partindo pro pros noq né então o que que a gente tem a gente continua usando o teorema Cap né então mas no início eh eh dos bancos de dados no SQL Então essas características então né Essas restrições elas foram assim flexibilizadas mais do que o que a gente flexibilizou lá no no teorema Cap né então aqui nos bancos de dados

- *Corpus ID:* 8873
- *Score:* 0.8662210702896118
- *URL:* oculto
- *Início:* 00:04:59
- *Fim:* 00:07:45
- *Transcrição:* sistema distribuídos E aí esses essas restrições E aí no terceiro momento né os desafios aí dos bancos de dados né no SQL das aplicações atuais que a gente tem E aí também de novo né esses essas restrições elas foram adaptadas mas a base ainda é é o que a gente tem eh no nos bancos de dados eh relacionais tá então lembrando lá dos bancos de dados relacionais né então aqui o que a gente tem eh né que a gente chama lá as restrições ácid que são quatro Então a gente tem eh a atomicidade de qualquer transação né então ela vai ser eh ela a gente né considera que o banco de dados continua consistente se eu executo ela e o resultado é como se ela tivesse né sido executada eh sozinha né e completamente Então ela é atômica e ou ela é executada ou ela é não executada né a consistência então cada transação ela vai preservar a consistência né da nossa base de dados então se eu executo lá uma transação a a base de dados estava consistente né Após a execução da transação ela continua consistente né O isolamento é quando a gente executa então um conjunto de transações e aí cada transação do conjunto eh o resultado dela deve ser considerado como se ela tivesse sido executada sozinha né então de novo aqui a gente vai sempre pro ponto de consistência o após né um conjunto de transações serem executadas o banco de dados sai de um estado consistente e vai para outro eh igualmente consistente e a durabilidade então depois né de executadas as transações e a base de dados modificada então o resultado então ele é permanente né então né o banco de dados o sgbd Então tem que garantir que o resultado atualizado né vai eh ficar sempre disponível por usuário mesmo que ocorra alguma algum tipo de F então aqui do ponto de vista né do eh do

- *Corpus ID:* 8876
- *Score:* 0.8653320670127869
- *URL:* oculto
- *Início:* 00:11:13
- *Fim:* 00:13:52
- *Transcrição:* tenho que garantir né que eh tenho que atualizar também o que tá em memória então eu melhorei o desempenho e coloquei em risco a consistência né então em bancos de dados distribuídos né então aqui só exemplos ali do que a gente viu né então eu posso ter lá da parte de compartilhamento de dados né eu tenho uma parte do dado que tá num servidor A outra tá em outro a outra tá em outro e a gente precisa eh eu aumento o desempenho porque eu posso executar isso em paralelo né Então aí a gente tem um ganho mas aí a gente pode perder eh na questão de consistência né Então aí a gente melhora bastante o com o compartilhamento de dados né então o desempenho mas aí a gente tem que cuidar paraa questão de consistência né e na replicação de dados então aí a gente né também de novo garante a o tempo de desempenho né bem melhor mas aí a gente tem problemas com a consistência porque eu tenho que manter todas as réplicas consistentes né então Eh o problema principal né É sempre manter essa consistência ou a disponibilidade então lá nos nos bancos de dados relacionais como a gente tinha tudo Centralizado sem distribuição então a gente conseguia manter sempre essas duas características né que é de existência e disponibilidade então aqui nos bancos de dados distribuídos né então o que que a gente tem aí a gente tem que tratar Eh esses dois aspectos né então aqui o principal é como pro particionamento como eu vou né Sincronizar as transações em várias partições Diferentes né para manter a consistência da base de dados na rplica ação como eu vou manter as réplicas sempre sincronizadas né quando eu tenho né dados em memória Cash então como eu vou sincronizar com os dados que estão armazenados de uma forma permanente né então nos bancos de dados distribuídos

- *Corpus ID:* 8884
- *Score:* 0.8592948913574219
- *URL:* oculto
- *Início:* 00:27:37
- *Fim:* 00:30:24
- *Transcrição:* distribuiu replicou fez cche mas a gente tinha os os dados mais estruturados né então agora quando a gente caminha pros nosql então aí a gente vai né incorporando novos desafios então agora né além do volume grande de dados que continua aumentando cada vez mais agora a gente tem os dados que tem eh estruturas diferentes e que isso também vai dificultar então tanto né a consistência quanto a disponibilidade e ao mesmo tempo né que a gente tem exemplos aí da Amazon e da Google que o tempo de resposta então tem um impacto ficeiro muito grande né então a gente eh tem que garantir Então esse desempenho Professor Oi sim no no slide anterior ali do Google eu acho que ficou faltando uma palavra ali meio segundo de aumento na latência faz com que o tráfego é em 1/5 depois de tráfego é deixa eu só ver aqui eh aqui aqui o eh também é eh com relação a que questão ficeira né então Eh se a gente aumenta a a latência aí o o tráfego de rede aqui também ele vai vai ser aumentado né em 1/5 aí eu vou beleza mas aqui a ideia toda assim quando a gente vai pro pros noeles né então é essa questão assim de desempenho e principalmente o daí a questão né ficeira então tenho que ter uma informação consistente e eu tenho que né ter uma rapidez né na resposta eh daí pro usuário então o tempo de resposta então ele é é bem importante aí o que que acontece né então a gente vai eh pras para pro teorema Cap de novo né então o início quando eh os bancos de dados no o SQL surgiram então nas primeiras aplicações então a ideia era usar continuar usando né as três restrições e usando o teorema Cap porque a gente continua né Com todas essas características de distribuição né então aqui a gente tem duas

- *Corpus ID:* 8757
- *Score:* 0.8588795065879822
- *URL:* oculto
- *Início:* 00:33:47
- *Fim:* 00:36:43
- *Transcrição:* valor dentro desses do noell né então Eh o Dinamo foi o primeiro deles e hoje né Amazon eh pro o suporte paraas quatro pros quatro tipos de bancos que a gente viu viu aqui né mas daí o principal eh ele surgiu aí com o Dinamo que era justamente para fazer o controle e acesso de usuários para recomendação né E então é o surgimento né do do do Dinamo então foi para essa finalidade né para fazer faz o controle de usuários E aí é um volume bem grande né de dados que a gente tem no mundo todo então aqui né a forma aqui eu assim simplifiquei bastante pra gente ter uma ideia geral né mas olhando aqui pro Dinamo e é uma característica que a gente encontra né em quase todos os fabricantes que é o da replicação né dos dados e do particionamento então o que que acontece o principal é o tempo de resposta né então a estrutura de dados é simples a gente tem um volume gigantesco de dados e a gente precisa de um tempo de resposta grande então Eh no Dinamo o que que acontece a gente tem as tabelas né Chave valor aí elas são replicadas né em três eh são em geral elas são replicadas eh em três nós Diferentes né para que a gente tenha sempre o valor eh disponível E aí a gente tem a distribuição né que graficamente então por exemplo o f eu tenho nesses três nós né o d eu tenho nesses três nós então a gente tem aí uma distribuição e uma replicação para que a gente eh tenha o dado Sempre disponível E se o o nó falha ele vai né pros dois vizinhos aí pra esquerda e pra direita então é uma estrutura circular de particionamento e replicação e daí com isso né a gente consegue garantir aí a a disponibilidade perdi meu mouse então a a ideia de replicação é essa né se aqui eu acabei falando antes se falha o nó então ele vai nos dois vizinhos aí para né responder à consulta do usuário né então A ideia é essa eu replico inters nós e nós Vizinhos se um deles falha

- *Corpus ID:* 8878
- *Score:* 0.8585349321365356
- *URL:* oculto
- *Início:* 00:15:18
- *Fim:* 00:18:08
- *Transcrição:* que ele faz então qualquer sistema distribuído ele tem que ele pode no caso né optar por duas propriedades E aí a gente consegue usando duas propriedades consegue garantir que a base de dados eh se mantém consistente né então aqui a gente tem consistência né disponibilidade e tolerância de partição Então a gente tem aí no caso três combinações Diferentes né então por exemplo aqui o que que a gente pode usar Então posso usar com consistência e e disponibilidade né Então aí a gente eh eh para aplicações onde a tolerância de partição então a a falha de rede não vai ter um impacto tão grande então no no desempenho e na consistência das aplicações né então aqui um outro tipo né de de combinação de consistência quando eu tenho a consistência dos dados Então eu preciso sempre trabalhar com os dados corretos Mas e a tolerância de partição Então eu tenho que eh cuidar né Para que se der alguma falha de rede o sistema né continue eh operando então aqui a gente nesse caso a gente vai flexibilizar a disponibilidade né então são para as aplicações em que a gente a gente pode né ficar um tempo com os dados indisponíveis até eles né voltarem e a última eh combinação que a gente tem então é disponibilidade e né tolerância de partição E aí a gente tem né uma a consistência ela pode est ameaçada né então aqui o que a gente vai fazer é para em cada um dos casos né a gente vai analisar o contexto da aplicação né E aí a gente vai ver quais são as necessidades prioritárias então tem alguns bancos de dados que mantém as três né aí a gente vai ter Possivelmente alguma penalização de desempenho mas muitos então assim o que é rígido que mantenha pelo menos duas restrições né então se eu pego por exemplo eh se lá um sistema bancário por exemplo eu preciso ter consistência e preciso ter

- *Corpus ID:* 8877
- *Score:* 0.8584929704666138
- *URL:* oculto
- *Início:* 00:13:12
- *Fim:* 00:15:57
- *Transcrição:* principal é como pro particionamento como eu vou né Sincronizar as transações em várias partições Diferentes né para manter a consistência da base de dados na rplica ação como eu vou manter as réplicas sempre sincronizadas né quando eu tenho né dados em memória Cash então como eu vou sincronizar com os dados que estão armazenados de uma forma permanente né então nos bancos de dados distribuídos né O que a gente tem então é o que é chamado de Teorema Cap né que são as três letras iniciais então aí quando eu tenho a distribuição né para eh resolver esses três Desafios que a gente tem aqui sempre olhando a consistência e a disponibilidade Então a gente tem as as as três restrições principais né então é consistência então cada nós sempre vê né enxerga os mesmos dados Então os dados sempre estão en ados corretamente né a disponibilidade é se ocorre uma falha né em um dos nós então toda a base de dados deve continuar disponível né pro usuário mesmo na ocorrência de falhas né E se a gente tem falha na rede então aqui a a terceira restrição que é né tolerância de partição então o sistema continua operando com a base de dados consistente então quando a gente vai né pros bancos de dados eh distribuídos é muito difícil eh conseguir essas três restrições ao mesmo tempo né então o teorema Cap né O que que ele faz então qualquer sistema distribuído ele tem que ele pode no caso né optar por duas propriedades E aí a gente consegue usando duas propriedades consegue garantir que a base de dados eh se mantém consistente né então aqui a gente tem consistência né disponibilidade e tolerância de partição Então a gente tem aí no caso três combinações Diferentes né então por exemplo aqui o


**Resposta gerada pelo LLM**: Particionamento de dados, replicação e cache.

**Referências**:
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()

**Anotação manual**: C

**Answer Relevance (AR)**: 0.33

**Anotação automatizada**: P

**Raciocínio (AR CoT)**: Criteria: The RESPONSE must be relevant to the entire PROMPT to get a maximum score of 3. It should address the three main challenges that arose with the emergence of distributed databases. Supporting Evidence: The RESPONSE mentions "particionamento de dados" (data partitioning), "replicação" (replication), and "cache." While these terms are related to challenges in distributed databases, the RESPONSE does not explicitly explain how they are challenges or provide context on their significance. Therefore, it does not fully address the PROMPT, which asks for the main challenges rather than just listing terms.  Score: 1


---
