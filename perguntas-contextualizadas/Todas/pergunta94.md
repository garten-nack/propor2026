**Pergunta 94**: O que é consistência eventual?

**Segmentos recuperados pelo E5**:
- *Corpus ID:* 8759
- *Score:* 0.8592982292175293
- *URL:* oculto
- *Início:* 00:38:04
- *Fim:* 00:40:44
- *Transcrição:* três nós então pode acontecer de uma leitura ela vai ser executada antes eh dela se atualizado Então vai consultar um valor que é inconsistente então o dínamo eles implementam aqui coloquei em destaque a consistência eventual né que é um caso especial da consistência fraca então eles né fazem permitem eh esse tipo de de execução né então eu gravo gravo faço a leitura que pode ser antes de uma gravação mas a consistência eventual é assim ó se eu acesso o nó para fazer uma leitura e o valor ainda não foi atualizado né vou só pegar aqui na então assim ó deu tempo de atualizar o de desse nó e desse nó e num terceiro não e a consulta vem aqui nesse terceiro nó então a consistência eventual que que é nesse momento antes de dar a resposta paraa leitura ele vai fazer a atualização ali daquele valor a consistência é eventual porque por exemplo se eu atualizo o d nesse nó e no segundo nó não atualizo no terceiro mas a consulta vem no primeiro ou no segundo então internamente a minha base tá inconsistente mas o usuário não tá percebendo isso né então aqui nessa consistência eventual a gente garante a corretude dos dados mas aí o tempo de resposta né então ele é minimizado com relação à consistência forte porque eu posso eh realizar consultas mesmo sem ter atualizado a todos os nós mas eles vão ser atualizados Em algum momento né então a consistência eventual Em resumo eu garanto a consistência por usuário né que é o que vai usar o dado mas internamente Em algum momento os nós alguns nós podem estar desatualizados eh al é Alexandre se eu deixa eu ver se eu entendi então Eh se eu fizesse uma consulta que ainda tivesse dois nós atualizados e um não eu teria que nos três aí eu veria que a informação mais atualizada está em dois nós e eu retornarei essa informação mas

- *Corpus ID:* 8887
- *Score:* 0.8411245942115784
- *URL:* oculto
- *Início:* 00:33:51
- *Fim:* 00:36:22
- *Transcrição:* usuário que tá usando aplicação né O que a regra diz é assim ó o O que que a que que os bancos de dados no sell propõe ele eu faço uma atualização então aqui por exemplo né Eh aqui eu fiz uma atualização no nó Então o que tá diretamente ligado e o que tá sendo usado Ele vai atualizar então aqui do lado esquerdo né eu tenho o conteúdo que ainda não foi atualizado mas no momento em que alguém acessar então ele ele vai fazer a atualização daquela informação né então aqui o que é uma consistência eventual que o que é o que os bancos de dados no esel né propõe é que o dado que tá sendo usado Ele tá atualizado se eu olho para toda a base de dados distribuída eu vou ter uma parte atualizada e uma parte não atualizada mas enquanto ninguém tiver usando né No momento que a pessoa que alguém acessa aí ela vai ser atualizada e vai ficar consistente Então deixa eu ver se eu entendi deixa eu ver se eu entendi quando bonequinho aí amarelo que tá tá do lado esquerdo ele precisa da web PGA só que ela foi atualizada do outro lado imediatamente vai essa web PGA vai ficar noat verdinho e ela vai enquanto ninguém precisar dela ela vai ficar laranjinha mas no momento que alguém precisar vai ficar verdinha exato perfeito nos distribuídos né quando eu faço uma atualização se eu tenho réplica ou atualizo todas as réplicas E aí a gente perde em desempenho porque eu tenho que parar e no particionamento também né todos os os as os nós da rede precisam acessar os dados de forma consistente então aqui no nos nocel então A ideia é que eu vou atualizar né ou eu posso atualizar quando o dado for necessário então a é exatamente isso né a consistência aqui do terceiro item é eventual é porque se eu tenho uma parte dos dados que ninguém tá usando ela vai tá inconsistente mas no momento que alguém

- *Corpus ID:* 1562
- *Score:* 0.8325415253639221
- *URL:* oculto
- *Início:* 01:30:33
- *Fim:* 01:32:35
- *Transcrição:* pequena ela não é uma constante arbitrária por exemplo né eu vou usar 0,001 a gente faz um pouquinho diferente isso aí existe um algoritmo chamado de correção de Laplace vocês vão ver em alguns lugares também chamados de Laplace smoot bem suavização de Laplace acho que seria a tradução tá isso algoritmo que ele faz é o seguinte ele assume ter uma Instância mais para cada valor possível desse atributo certo então ele assume uma Instância fictícia ou seja essa distância ela nunca é inserida no dado é como se ele colocasse no cálculo da probabilidade condicional sempre é uma constante dizendo Olha eu tenho no mínimo eu vou assumir que eu tenho no mínimo uma Instância para aquele valor de atributo para aquela classe então por exemplo para vento igual assim nesse problema aqui eu tenho cinco instâncias só que eu tô assumindo uma pessoa fictícia ou virtual né ela não é inserida não é a base de dados ela inserida como uma constante no meu cálculo para vento igual a não eu faço a mesma coisa assumo opa pera aí desculpe assumo uma Instância extra aqui voltando aqui assuma uma Instância Extra e o meu valor original é zero então o resultado disso é que se eu tô assumindo que eu sempre tenho pelo menos uma com sim uma com não na minha classe parmegiana no caso que eu não tiver nenhuma eu não vou ter zero eu vou ter um né no numerador só que o denominador ele ajusta porque eu não posso ter probabilidades acima de um né se eu colocasse aqui cinco mais um seis e dividisse por 5 que é o denominador original eu teria uma probabilidade acima de um então para ajustar o fato de eu estou assumindo que eu tenho uma Instância mais para cada valor da tributo o meu denominador é ajustado com o número de valores possíveis para esse atributo Porque se o atributo tem

- *Corpus ID:* 8886
- *Score:* 0.8262876868247986
- *URL:* oculto
- *Início:* 00:31:43
- *Fim:* 00:34:35
- *Transcrição:* consistência então né o sistema fica mais rápido e fica mais fácil de implementar então partindo pro pros noq né então o que que a gente tem a gente continua usando o teorema Cap né então mas no início eh eh dos bancos de dados no SQL Então essas características então né Essas restrições elas foram assim flexibilizadas mais do que o que a gente flexibilizou lá no no teorema Cap né então aqui nos bancos de dados Noel então a a gente chama de propriedades base né então é aqui eu garanto né basicamente disponível então ele tá disponível mas a gente pode ter por exemplo um certo atraso né vou mostrar um exemplo aí logo na sequência aqui a gente tem com soft um estado soft né então o conteúdo do dos dados ele pode ir atualizando ao longo do tempo né Ou seja eu faço uma atualização num ponto e ele pode demorar um pouco até a atualização de todos os outros pontos né e a consistência eventual que tem bastante relação com essa segunda consistência aqui que é que o sistema eventualmente ou momentaneamente ele pode est inconsistente né então então desculpa então significa que quando eu precisar de um dado Pode ser que eu não pegue a última verção desse dados Hã eu vou mostrar esse outro aqui que é o o próximo exemplo da que eu acho que daí vai responder bem a tua pergunta então assim ó aqui eh a gente vai manter a consistência pro usuário que tá usando aplicação né O que a regra diz é assim ó o O que que a que que os bancos de dados no sell propõe ele eu faço uma atualização então aqui por exemplo né Eh aqui eu fiz uma atualização no nó Então o que tá diretamente ligado e o que tá sendo usado Ele vai atualizar então aqui do lado esquerdo né eu tenho o conteúdo que ainda não foi atualizado mas no momento em que alguém acessar então ele ele vai fazer a atualização daquela informação

- *Corpus ID:* 8758
- *Score:* 0.8244178891181946
- *URL:* oculto
- *Início:* 00:35:58
- *Fim:* 00:38:47
- *Transcrição:* ele vai né pros dois vizinhos aí pra esquerda e pra direita então é uma estrutura circular de particionamento e replicação e daí com isso né a gente consegue garantir aí a a disponibilidade perdi meu mouse então a a ideia de replicação é essa né se aqui eu acabei falando antes se falha o nó então ele vai nos dois vizinhos aí para né responder à consulta do usuário né então A ideia é essa eu replico inters nós e nós Vizinhos se um deles falha Então a gente vai né pros vizinhos Então essa aqui é a ideia original com relação à consistência então assim ó o que que acontece eh aqui a gente tem assim né a aqui a né uma explicação e uma definição de uma fórmula então tenho a escrita e a leitura numa consistência forte o que que acontece né sempre vai ser maior do que o número de nós então vou fazer a escrita primeiro né E depois vou fazer a leitura para garantir né que qualquer eh leitura ela faça num valor num valor consistente correto né então aqui por exemplo eh se eu tenho ele um valor aqui em D que tá replicado em três nós diferentes eu vou fazer as três escritas e só depois eu vou fazer a leitura né então é o que eles chamam de consistência forte a consistência fraca eh que é assim eu posso eu vou fazer eh as operações então tenho escrita escrita escrita e leitura né que são quatro e daí eles estão replicados em três nós então pode acontecer de uma leitura ela vai ser executada antes eh dela se atualizado Então vai consultar um valor que é inconsistente então o dínamo eles implementam aqui coloquei em destaque a consistência eventual né que é um caso especial da consistência fraca então eles né fazem permitem eh esse tipo de de execução né então eu gravo gravo faço a leitura que pode ser antes de uma gravação mas a consistência

- *Corpus ID:* 8878
- *Score:* 0.8229924440383911
- *URL:* oculto
- *Início:* 00:15:18
- *Fim:* 00:18:08
- *Transcrição:* que ele faz então qualquer sistema distribuído ele tem que ele pode no caso né optar por duas propriedades E aí a gente consegue usando duas propriedades consegue garantir que a base de dados eh se mantém consistente né então aqui a gente tem consistência né disponibilidade e tolerância de partição Então a gente tem aí no caso três combinações Diferentes né então por exemplo aqui o que que a gente pode usar Então posso usar com consistência e e disponibilidade né Então aí a gente eh eh para aplicações onde a tolerância de partição então a a falha de rede não vai ter um impacto tão grande então no no desempenho e na consistência das aplicações né então aqui um outro tipo né de de combinação de consistência quando eu tenho a consistência dos dados Então eu preciso sempre trabalhar com os dados corretos Mas e a tolerância de partição Então eu tenho que eh cuidar né Para que se der alguma falha de rede o sistema né continue eh operando então aqui a gente nesse caso a gente vai flexibilizar a disponibilidade né então são para as aplicações em que a gente a gente pode né ficar um tempo com os dados indisponíveis até eles né voltarem e a última eh combinação que a gente tem então é disponibilidade e né tolerância de partição E aí a gente tem né uma a consistência ela pode est ameaçada né então aqui o que a gente vai fazer é para em cada um dos casos né a gente vai analisar o contexto da aplicação né E aí a gente vai ver quais são as necessidades prioritárias então tem alguns bancos de dados que mantém as três né aí a gente vai ter Possivelmente alguma penalização de desempenho mas muitos então assim o que é rígido que mantenha pelo menos duas restrições né então se eu pego por exemplo eh se lá um sistema bancário por exemplo eu preciso ter consistência e preciso ter

- *Corpus ID:* 8890
- *Score:* 0.8203132152557373
- *URL:* oculto
- *Início:* 00:39:48
- *Fim:* 00:42:45
- *Transcrição:* corrigir ali depois Opa tá eh a tá aqui então assim aqui só pra gente né terminar aqui uma comparação eh assim esse triângulo aqui do cap né Eh a cada dia então eh a gente muda bastante dependendo eh do que os fabricantes né vão oferecendo então aqui né O que a gente tem a disponibilidade consistência e né tolerância de pares são Então os bancos de dados relacionais os né como é tudo Centralizado então a gente não tem esse problema que tá aqui então a gente tem né A consistência e a disponibilidade E aí os bancos de dados então Eh os nocel então eles vão assim eh colocando o que é prioritário né então por exemplo aqui nessa figura o mongo DB eh diz que né então o que é prioritário é a consistência e a tolerância de partição né então quando eu faço uma atualização ele já vai atualizar em todos os locais onde a gente tem o dado e penaliza a disponibilidade Aproveitando né a a pergunta anterior lá da minha figura né dos bonequinhos assim aqui o que a gente tem é que é penalizado né como eu respondi ali para consistência mas o mesmo vale para disponibilidade mas não quer dizer que não tenha né então a gente vai levar mais tempo para alcançar Mas a gente sempre vai né trabalhar com os dados consistentes e os dados não vão ser perdidos né então a gente mantém também a a restrição de dura abilidade que é como a gente tem então lá no nos nos relacionais né então aqui assim ó a esse triângulo aqui peguei de uma publicação né que coloca né a prioridade da dos bancos de dados né vou pegar aqui só dois exemplos então o mongo DB que tem sido muito utilizado para aplicações transacionais né Tem muitas empresas migrando pro mongo DB então a essa consistência imediata então é uma característica que ela é bastante prioritária né o Cassandra a gente pode olhar que ele eu tenho a disponibilidade

- *Corpus ID:* 8889
- *Score:* 0.8191542625427246
- *URL:* oculto
- *Início:* 00:37:36
- *Fim:* 00:40:37
- *Transcrição:* impressão eu vou até aqui anotar o número do slide eu vou atualizar que depois atualizo o mú de novo tá até aqui Alguém tem mais algum ponto complemento ou dúvidas professora uma dúvida essa consistência é ela só é alcançada então Quando um usuário fizer o acesso a esse dado ou depois de algum tempo isso é atualizado mesmo se o dado não for acessado sim depois assim ó a aí cada banco pode implementar de uma forma diferente né o que ele tem que garantir é que quando eh o usuário acesse o dado vai est consistente eu vou usar o exemplo do Mongo DB porque eu trabalho bastante com ele né o mongo DB ele já vai atualizando né então Eh respondendo à tua pergunta sim alguns bancos já fazem essa atualização o que é regra é que quando o usuário acessa ele tem que operar com uma base de dados consistente né mas eh alguns bancos atualizam só quando o usuário acessa né então Eh aí eles ganham um desempenho porque se tem uma informação que não é muito acessada ela né fica inconsistente até que seja acessado mas a maioria dos bancos de dados elas já vão já vão atualizando eh assim que possível né então Eh é essa é a diferença que a gente tem e reforçando o principal é que o usuário sem vai operar com a base de dados atualizada É sim aí obrigado Garten ali né comentou pela a tradução ali do do inglês é eventual só vou anotar aqui que eu vou corrigir ali depois Opa tá eh a tá aqui então assim aqui só pra gente né terminar aqui uma comparação eh assim esse triângulo aqui do cap né Eh a cada dia então eh a gente muda bastante dependendo eh do que os fabricantes né vão oferecendo então aqui né O que a gente tem a disponibilidade consistência e né tolerância de pares são Então os bancos de dados relacionais os né como é tudo Centralizado então a

- *Corpus ID:* 8888
- *Score:* 0.8186057209968567
- *URL:* oculto
- *Início:* 00:35:43
- *Fim:* 00:38:17
- *Transcrição:* todos os os as os nós da rede precisam acessar os dados de forma consistente então aqui no nos nocel então A ideia é que eu vou atualizar né ou eu posso atualizar quando o dado for necessário então a é exatamente isso né a consistência aqui do terceiro item é eventual é porque se eu tenho uma parte dos dados que ninguém tá usando ela vai tá inconsistente mas no momento que alguém usa ela vai ser atualizada e todo mundo vai trabalhar então Eh com os dados consistentes né Então essa eh é a ideia que é proposta aqui pelos nosql professora Mas então no final das contas a consistência é garantida né a consistência sempre é garantida sim garan tá beleza é porque assim quando a gente lê o slide fica parecendo Eh que que não não é garantido mas com com a com a quando você colocou Aí o exemplo né da animação no final das contas para quem interessa que é o usuário final tá garantido sim perfeito eu eu vou até anotar aqui no outro slide Eu também anotei vou colocar alguma sinalização aqui para que não não passe essa impressão né porque em todos eles né que é o objetivo principal de banco de dados é manter a consistência então a consistência né tem que ser garantida sempre não posso eh trabalhar com valor Val é desatualizado mas realmente antes da gente ir pro exemplo olhando aqui então passa essa impressão eu vou até aqui anotar o número do slide eu vou atualizar que depois atualizo o mú de novo tá até aqui Alguém tem mais algum ponto complemento ou dúvidas professora uma dúvida essa consistência é ela só é alcançada então Quando um usuário fizer o acesso a esse dado ou depois de algum tempo isso é atualizado mesmo se o dado não for acessado sim depois assim ó a aí cada banco pode

- *Corpus ID:* 622
- *Score:* 0.8177610635757446
- *URL:* oculto
- *Início:* 00:09:44
- *Fim:* 00:11:57
- *Transcrição:* é um problema né na estimação dos nossos coeficientes então se eu tiver um outline eu tenho que tratar esses meus dados eles têm que sair isso uma vez só no exemplo do marido tem um probleminha se esse eu tenho aqui que é o meu padrão aqui eu espero esses valores e que não passando muito de dois ou três desvios dois desvios aquele 1 96 padronizados para mais que eles não passem disso ou dando uma escapadinha lembram lá né que até um por cento a gente pode porque os pressupostos de novo lembram de robustez né os métodos paraméticos são bastante robustos então desvios leves de algum pressuposto ainda assim o modelo se comporta de forma adequada tá tranquila para ser utilizada então geralmente a gente fala se não passar de três desvios para menos para mais tá tranquilo não temos Outlander tá então aqui olhando este caso que é um problema não vou ter Outlander aqui a variância não constante que a homossedicidade que a gente falou né a homossedicidade eu não posso enxergar esse tipo de funil ou seja para valores menores eu tenho uma parabidade menor e para valores maiores eu tenho uma variedade maior Isso não pode acontecer tá porque isso é uma das cidades heterossedicidade tem modelos que trabalham com variância não constante tá então daí é complicador vários complicadores tá tem formas de resolver isso só que são complicadores da regressão linear os teus resíduos são uma variável né pensando aqui no sentido lá de variável um conjunto de dados como é que ele calcula como é que ele calcula esse funil esse tipo assim a vargância é exatamente aplicada aquele negócio você pega a média aí subtrai cada valor dos resíduos pela média dos resíduos leva ao quadrado e tal e depois e depois divide pela pelo número de resíduos não é isso assim essa negócio


**Resposta gerada pelo LLM**: Consistência eventual é um tipo de consistência fraca onde a corretude dos dados é garantida para o usuário, mas internamente alguns nós podem estar desatualizados por algum tempo.  Em bancos de dados NoSQL, a atualização ocorre quando o dado é necessário, mantendo a consistência para quem o utiliza, mesmo que partes da base de dados estejam inconsistentes temporariamente.  A atualização é feita no momento do acesso, garantindo que o usuário opere com dados consistentes.

**Referências**:
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()

**Anotação manual**: C

**Answer Relevance (AR)**: 1.00

**Anotação automatizada**: C

**Raciocínio (AR CoT)**: Criteria: The RESPONSE must be relevant to the entire PROMPT to receive a maximum score of 3. Supporting Evidence: The RESPONSE directly addresses the PROMPT by defining "consistência eventual" and explaining its characteristics in the context of NoSQL databases. It provides a clear explanation of how eventual consistency works, including the concept of temporary inconsistencies and the guarantee of data correctness for users. This comprehensive explanation covers the key aspects of the PROMPT, demonstrating a full understanding of the topic.  Score: 3


---
