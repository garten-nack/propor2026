**Pergunta 108**: Como o parâmetro alfa influencia a poda no algoritmo de custo complexidade?

**Segmentos recuperados pelo E5**:
- *Corpus ID:* 1916
- *Score:* 0.8891432881355286
- *URL:* oculto
- *Início:* 01:26:52
- *Fim:* 01:28:48
- *Transcrição:* próprio algoritmo custo complexidade porque o critério do algoritmo né o algoritmo que era um equilíbrio e aí a gente vai mudando o alfa para ver o quanto que a gente tá pesando a complexidade para reduzir mais a complexidade mas o algoritmo é guiado por esse equilíbrio então é natural que ele tenha um resultado melhor em termos desse equilíbrio certo porque é basicamente é o que nos orienta no algoritmo de custo complexidade também é possível combinar para ir para as poda tá por exemplo eu posso ter vamos supor que eu tenho uma árvores de decisão que sem qualquer critério de poda a profundidade máxima foi de 20 por exemplo eu posso decidir olha Quero fazer um pré poda com uma profundidade máxima de 15 que ainda é bem profunda e aplicar após depois após poda ela vai ser mais rápido com certeza então é possível combinar tá para alguns casos a gente não chega a exercitar isso no notebook mas é algo possível então só quero dizer que existe essa possibilidade né embora muitas vezes é comum pessoal trabalhar com um ou com outra dependendo do caso Vocês poderiam decidir por combinar para tornar mais rápido dependendo se a árvore ficou muito profunda tá E aí eu chamo atenção para essa para navalha de hokan ou kansahaser talvez alguns de vocês já já tem ouvido falar e isso não vale só para árvores de decisão vale para tudo em aprendizado de máquina né Se eu tiver dois modelos com erros de generalização similares então por exemplo dois modelos que tendem né até o mesmo desempenho e dados Independentes eu sempre devo de uma forma geral preferir o modelo mais simples porque o modelo mais simples ele sempre vai ter a tendência de generalizar melhor novos dados porque tem aquela questão a gente quando avalia poder generalização é como amostra e mas a gente quer que esse poder né de generalização se reproduza nos dados quando esse modelo de fato for

- *Corpus ID:* 1889
- *Score:* 0.8887085914611816
- *URL:* oculto
- *Início:* 00:42:21
- *Fim:* 00:44:55
- *Transcrição:* ramificar tá então é isso que a gente tenta fazer só que após o treinamento Não durante o treinamento né isso após o treinamento então aqui entendendo um pouquinho né como é que é de fato essa questão a gente tem então essa função que basicamente aqui tem um hiper parâmetro Alfa que a gente chama o alfa né maior que zero que é esse parâmetro complexidade que basicamente ele vai definir essa medida de custo complexidade vai determinar o quanto né que eu quero por exemplo limitar essa árvore em função da sua estrutura né da complexidade quanto que eu tô ponderando isso então aqui esse meu ter módulo de T é o tamanho da árvore né dado em função por exemplo do número de nós folhas Tá quanto mais nós folhas mais complexa é a minha árvore tá e tende a ser mais profunda também existe uma correlação aí então aqui seria o tamanho eu vou chamar aqui tá ou complexidade né A complexidade e esse rdt é o erro tá ou custo Então o que ele tenta fazer né para diferentes valores de Alfa é justamente é podar essa árvore de forma a ter um equilíbrio entre custo complexidade Então o que a gente vai ver que na prática se eu tenho um valor de Alfa Grande mas a minha árvore é podada porque eu estou pesando mais a complexidade então eu tô dizendo que aquilo é uma característica que tá que eu tô ponderando mais então a poda vai ser mais drástica certo o número de Ramos que ele tem lá do lado que ele tá fazendo abaixo do nó que ele tá fazendo esse esse total é número total só que ele Claro ele vai fazendo isso para subir árvores tá ele ele vai fazendo então tá então ele vai fazer tudo fazer

- *Corpus ID:* 1888
- *Score:* 0.8837385177612305
- *URL:* oculto
- *Início:* 00:40:38
- *Fim:* 00:42:55
- *Transcrição:* que esse algoritmo faz ele vai iniciar da base ou seja não dou uma raiz né dos mais profundos e ele avalia para cada no interno como é que fica o custo complexidade da sub- árvore ou seja né daquela árvore que eu tenho a partir daquele nó interno tá e como é que fica a diferença se eu podar aquela sub- árvore ou seja se eu pegasse e trocar por uma folha onde esse na folha ele vai a saída dele vai ser determinado por exemplo pelo valor mais provável de Todas aquelas instâncias que caem naquele nó tá então só para deixar um exemplo para vocês aqui É como se eu tivesse dizendo para vocês o seguinte olha vamos pegar essa sub- árvore aqui Tá e isso aqui eu vou substituir por um nó folha tá então esse aqui vai ser agora uma folha não vai ser mais uma sobre a árvore e aí como é que Eu determino a classe aqui é a classe mais provável olha só aqui eu tenho eu tô colocando laranja vai ficar difícil ver aqui as classes eu tenho 141 instâncias de uma classe quatro da outra eu vou chamar aqui de Classe A e B tá então o que que eu diria olha todo mundo que vira para cá né O que chegar aqui agora vai para esse na folha e aqui a classe vai ser a porque ela é mais provável tá então eu tô trocando toda essa estrutura por esse na folha e aí Claro a definição da saída é muito em função das instâncias que estão na naquele na interno que eu vou subdividir ramificar tá então é isso que a gente tenta fazer só que após o treinamento Não durante o treinamento né isso após o treinamento então aqui entendendo um pouquinho né como é que é de fato essa questão a gente tem então essa função que basicamente aqui tem um hiper parâmetro Alfa que a gente chama o alfa né maior que zero que é esse parâmetro complexidade que basicamente ele vai definir essa medida de custo

- *Corpus ID:* 1891
- *Score:* 0.8828375935554504
- *URL:* oculto
- *Início:* 00:45:50
- *Fim:* 00:47:50
- *Transcrição:* sem nenhuma restrição exato a gente vai ver que tem essa esse trade entre quanto maior o alfa menor a minha árvore e aí o que a gente vai ter que descobrir é justamente Qual é o alfa que me dá esse melhor equilíbrio entre o erro né daquela árvore podada e a complexidade daquela árvore tamanho tá pode entrar um Grid CV né para ele fazer um grito de se ver para ele poder fazer o teste entre esses parâmetros para a gente escolher o mesmo exato Exatamente isso é algo que a gente também vai ter que configurar né então os dois as duas estratégias de poda entram testes né variações esses valores e teste para que a gente possa definir qual é o melhor para os nossos dados tá e a gente vai nos dois casos testar no notebook inclusive para o pós poda a gente vai ver eu acho que eu coloquei aqui nos slides coloquei aqui nos slides Depois tem lá no final do notebook o próprio site planner Tem uma função para tentar estimar esse valor de alfa o valor de Alfa efetivo que ele chama que é aquele que de fato vai causar né uma poda que gera uma mudança na árvore que diminui a minha complexidade é claro quanto maior o valor de Alfa mas ele vai estar diminuindo tá então que a gente quer é realmente ver uma forma de escolher Se melhorar Alfa mas sempre buscando esse equilíbrio entre reduzir o erro e controlar o nível de complexidade tá então porque assim que que acontece eu eu a minha árvore é muito profunda eu vou podando ela eu vou ter algum ponto que eu tô diminuindo a complexidade e de repente melhorando o desempenho porque ela se torna ela ela passa a ter uma capacidade generalização maior só que a medida que eu vou exigindo muito a minha profundidade Pode ser que meu erro começa a aumentar Porque daí a minha árvore tá gerando tipo um wonderfiten certo ela tá sendo muito simples para classificar né ou fazer uma regressão

- *Corpus ID:* 1911
- *Score:* 0.8825287818908691
- *URL:* oculto
- *Início:* 01:18:43
- *Fim:* 01:21:07
- *Transcrição:* complexidade mas o notebook vocês vão ver que esses códigos eles estão ao final como o material opcional Tá mas é resolvia que já mostrar para vocês como é que seria essa forma mais completa não segue antes de fazer porque ele estima valores de Alfa efetivos efetivos no sentido de diminuir a complexidade da árvore a gente tem que ver qual é o melhor do ponto de vista do equilíbrio de custo então eu não tô testando nada aqui né nesses valores aqui eu tô testando esse e esse Então o que tá Entre esses valores aqui não necessariamente vai gerar os mesmos resultados ali só que o que acontece como a gente está usando essa função de analisar com os efetivos o que nos o que a gente pode entender o seguinte provavelmente são valores que não vale a pena testar que vai ser o mesmo o mesmo tipo de corte né isso porque eu tô usando esses alfas efetivos tá se eu tivesse testando o intervalos arbitrários aqui realmente não tem como a gente saber se por exemplo 0.010.013 vai me dar o mesmo o mesmo mesmo tipo de resultado a mesma coisa aqui que eu tenho esse intervalo aqui também eu tô testando esse valor e esse porque o algoritmo e esse diz que não vale a pena testar nada aqui dentro tá mas se eu tivesse fazendo isso de novo ele valores arbitrários a gente não tem como saber se um 0,03 vai causar alguma diferença em relação a esse 0,024 por exemplo de nada eu não sei o que aconteceu aqui que ele não tá deixando eu voltar para o zoom aqui tá [Aplausos] Então deixa eu ver se eu consigo eu queria que no final mas não sei deu algum bug aqui no meu Deixa eu só vi uma coisa aqui aqui eu vou abrir de novo ele tá um pouco lento porque tá acabando a bateria

- *Corpus ID:* 1915
- *Score:* 0.8817685842514038
- *URL:* oculto
- *Início:* 01:25:21
- *Fim:* 01:27:18
- *Transcrição:* tá muitas vezes ela pode chegar um resultado bom assim bastante competitivo com pós poda o que pode acontecer é que essa esse orlestoping que é o que acontece com pré-poda tem essa desvantagem de ser o que a gente chama de uma estratégia gulosa porque Eu determino Essa é minha profundidade máxima por exemplo e eu e eu ignoro o fato de que depois daquela profundidade podem surgir algumas partições que podem melhorar eventualmente o desempenho Ou seja a profundidade máxima ela se ela for muito profunda ela pode piorar muito mas algo intermediário Pode ser que melhore um pouco meu desempenho e me dê regras mais específicas para alguns casos tá então Como tudo tem vantagens e desvantagem né o treinamento ele costuma ser mais rápido mas tem essa questão da gente ignorar o fato de que por exemplo depois de uma profundidade máxima de três na profundidade máxima de quatro poderiam surge coisas que até melhor o desempenho em relação a de três por isso que na prática o que a gente tem que fazer um processo de otimização de parâmetros a gente não tem muito como fugir disso tá de qual é o melhor critério de propósito após pó ela pode ser lenta quando tem um conjunto de dados grandes muitas instâncias muitos atributos mas ela tem de ser mais efetiva nesse equilíbrio entre complexidade e desempenho né o custo né aqui o desempenho estava chamando antes de custo né que é o próprio algoritmo custo complexidade porque o critério do algoritmo né o algoritmo que era um equilíbrio e aí a gente vai mudando o alfa para ver o quanto que a gente tá pesando a complexidade para reduzir mais a complexidade mas o algoritmo é guiado por esse equilíbrio então é natural que ele tenha um resultado melhor em termos desse equilíbrio certo porque é basicamente é o que nos orienta no algoritmo de custo complexidade

- *Corpus ID:* 1900
- *Score:* 0.8786852359771729
- *URL:* oculto
- *Início:* 01:01:07
- *Fim:* 01:03:12
- *Transcrição:* forma mais genérica complexidade é o quão complexo é essa estrutura né o quão a dimensão dessa árvore né então aqui eu tô mostrando sobre dois aspectos o número de nós e a profundidade então a gente pode ver que conforme a gente aumenta o valor de Alfa minha profundidade diminui conforme eu diminuo o valor de Alfa minha profundidade aumenta então percebam que quanto maior o alfa menos profunda a minha a minha árvore né e a mesma coisa em termos o número de nós quanto mais maior o meu alfa menos nós eu tenho porque eu tô podando mais a árvore quanto menor o meu alfa mas nós eu tenho porque eu tô podando menos a minha árvore tá só para você ficar claro essa relação de que quanto maior o alfa mas eu tô podando a minha árvore E aí a gente precisa definir qual é o melhor valor de Alfa tá E para definir qual é o melhor valor de Alfa a gente faz isso normalmente olhando o desempenho tá então aqui tô chamando de uma forma geral de treino e teste aqui tá pelo inclusive o código que tá no site planner Mas lembre que o ideal é sempre a gente fazer essa balização treino de visão treino validação e teste né que a validação que são Dados Independentes a gente usa para tomar essa decisão tá então deixando um pouquinho esse detalhe de lado que eu colocaria aqui no chamaria de diferente validação não teste o que a gente está observando aqui é em azul dados de Treinamento tá em laranja dados que ele não viu em tempo de treinamento tá são Dados independentes e aqui a gente tem o valor de alfa e aqui é acurácia no eixo Y tá então o que que a gente tá observando a gente tá vendo que a medida que a gente vai aumentando alfa o que que acontece com ela diminui a complexidade certo isso é um efeito então maior Alfa árvores menos complexas e o que a gente está observando é que quando não tenho nada de poda aqui eu tenho uma curaça de 100% a medida que eu

- *Corpus ID:* 1892
- *Score:* 0.8781530261039734
- *URL:* oculto
- *Início:* 00:47:22
- *Fim:* 00:49:33
- *Transcrição:* vou podando ela eu vou ter algum ponto que eu tô diminuindo a complexidade e de repente melhorando o desempenho porque ela se torna ela ela passa a ter uma capacidade generalização maior só que a medida que eu vou exigindo muito a minha profundidade Pode ser que meu erro começa a aumentar Porque daí a minha árvore tá gerando tipo um wonderfiten certo ela tá sendo muito simples para classificar né ou fazer uma regressão por determinado problema Por isso que existe se tirar demais não defende Exatamente exatamente e como é que a gente seleciona o melhor valor de Alfa Tá eu vou mostrar aqui alguns exemplos isso vai estar lá no notebook tá mas também quis deixar aqui no material que quando a gente vai buscar esse menor valor de Alfa é uma é de forma semelhante ao que a gente fez para otimizar e pelo parâmetros tá como KNN do o KNN por exemplo ou a regularização no svn tá então a gente testa Vários valores avalia desempenho e busca aquele que melhora o desempenho tá só que esse valor de Alfa para gente como eu falei Depende muito da estrutura da árvore e o site tem uma função que é o cós complexo complexo the runing pack tá que ele avalia diferentes valores de alfa e retorna valores efetivos são valores que vale a pena a gente testar porque eu poderia por exemplo variar de zero a zero ponto cinco pulando de zero ponto zero cinco então eu poderia estabelecer né qualquer conjunto qualquer sequência Mas o que ele faz é o seguinte são valores motivos que ele diz que de fato causam mudança na árvore né E aí a gente avalia o impacto essa mudança do ponto de vista do custo então em outras palavras esses alfas efetivos são sugestões de Valores para a gente testar como Alfa tá então é isso é essa função auxilia nessa busca de valores de Alfa que de fato vão

- *Corpus ID:* 1910
- *Score:* 0.8748858571052551
- *URL:* oculto
- *Início:* 01:17:06
- *Fim:* 01:19:15
- *Transcrição:* falar esse gráfico aí de baixo no outro que tá esse aqui do desempenho sim sim esse Alfa aí esse ponto aí mas pode ser qualquer coisa desse intervalo aí né entre 0.01 e 0.019 talvez ali não quero faz diferença se aceitar 0.01 a 0.19 qualquer valor desse Alfa aí para mim é válido é isso não é que na verdade não porque eu não eu não tenho desculpas eu não tenho eu não testei esses valores tá eu não testei nada entre esse valor aqui E esse aqui eu não testei então isso aqui não necessariamente é uma reta tá ele pode até ter dentes se eu tivesse testado é por causa do valor que eu testei E aí por que que a gente testou esses valores isso é importante mencionar porque esse basicamente essa análise que a gente fez aqui tô tentando diminuir essa análise que a gente fez aqui ela me retornou alguns valores efetivos são aqueles valores que vão causar alguma alteração na árvore tá então eles tinham esses valores como aqueles que vale a pena a gente testar então vocês perceberam aquela função que você falou no começo que ele vai te dar um mês né ele existe uma função que já dá esses alfa e depois você faz os testes utilizando estes Alves Exato eu já era uma lista de valores de Alfa Poderia gerar uma lista manualmente vocês vão ver no notebook que a gente vai fazer isso no primeiro momento Tá eu já tô explicando aqui a forma que normalmente a gente usa o curso complexidade mas o notebook vocês vão ver que esses códigos eles estão ao final como o material opcional Tá mas é resolvia que já mostrar para vocês como é que seria essa forma mais completa não segue antes de fazer porque ele estima valores de Alfa efetivos efetivos no sentido de diminuir a complexidade da árvore a gente tem que ver qual é o melhor do ponto de vista do equilíbrio de custo então eu não tô testando nada aqui né nesses valores

- *Corpus ID:* 1955
- *Score:* 0.8748050928115845
- *URL:* oculto
- *Início:* 01:02:46
- *Fim:* 01:05:02
- *Transcrição:* overfling certo OK tá joia bom a gente vai fazer exercício dessa questão de seleção de do Hiper parâmetro tá é mas antes da gente então a gente viu que algumas variações a gente não tá avaliando né especificamente Qual é o melhor mas eu queria fazer avaliação com vocês dessa questão do pós poda tá então posso poda também tem o hiper parâmetro o que a gente fizer aqui de lógica de programação para escolher o hipermetroalfa que é o quanto que eu tô ponderando a questão da complexidade da minha árvore essa mesma lógica poderia aplicar para esses hiper parâmetros de pré poda tá bem então a biblioteca ela tem essa essa Essas funções né de plot costas demais esses valores de Alfa efetivos a gente vai fazer alguns testes aqui tá um pouquinho mais algumas coisas um pouquinho mais manuais para vocês verem a diferença tá então quando a gente tá fazendo pós poda lembrem a gente treina toda a árvore depois a gente escolhe um valor de Alfa né que é Para justamente usar naquela equação para definir quando que eu vou trocar uma sub árvore por uma folha então aqui eu tô usando desses falha usando um valor de que é esse preparamos CCB Alfa arbitrário tá só para vocês observarem a diferença entre eu ter um valor de Alfa baixo e um valor de Alfa mais alto tá eu vou executar esses dois aqui para vocês verem a diferença na estrutura da árvore aqui eu tenho um valor de Alfa baixo tá 0.001 certo então percebam que tem uma árvore né profundidade um dois três quatro cinco seis sete Tá e agora eu vou rodar na célula seguinte com valor de Alfa 05 o valor de Alfa 05 Olha só me dá uma árvore de decisão com uma profundidade de dois então só para vocês verem que de fato né


**Resposta gerada pelo LLM**: Quanto maior o valor de alfa, maior a poda da árvore, pois a complexidade é mais ponderada.  Um alfa grande resulta em uma árvore mais podada, enquanto um alfa pequeno resulta em uma poda menos drástica.  A escolha do melhor alfa envolve encontrar um equilíbrio entre o erro e a complexidade da árvore, buscando o melhor desempenho.

**Referências**:
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()
- [Vídeo de referência oculto]()

**Anotação manual**: C

**Answer Relevance (AR)**: 1.00

**Anotação automatizada**: C

**Raciocínio (AR CoT)**: Criteria: The RESPONSE must be relevant to the entire PROMPT to receive a maximum score of 3. It should address how the parameter alpha influences pruning in the cost complexity algorithm. Supporting Evidence: The RESPONSE directly addresses the influence of the alpha parameter on pruning in the cost complexity algorithm. It explains that a higher alpha leads to more pruning, while a lower alpha results in less pruning. Additionally, it discusses the balance between error and complexity, which is relevant to the overall understanding of the algorithm's performance. This comprehensive explanation covers all aspects of the PROMPT.  Score: 3


---
